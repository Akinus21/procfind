#!/bin/bash

set -euo pipefail

# --- Color setup ---
RED=$(printf '\033[0;31m')
NC=$(printf '\033[0m')
GREEN=$(printf '\033[0;32m')

# --- Script and install path ---
SCRIPT_NAME="procfind"
INSTALL_PATH="/usr/bin/$SCRIPT_NAME"
REAL_PATH="$(realpath "$0")"
SCRIPT_DIR="$(dirname "$REAL_PATH")"

# --- Git update check ---
if [[ -d "$SCRIPT_DIR/.git" ]]; then
    cd "$SCRIPT_DIR" || exit 1
    git fetch --quiet
    LOCAL_HASH=$(git rev-parse HEAD)
    REMOTE_HASH=$(git rev-parse @{u} 2>/dev/null || echo "")
    if [[ -n "$REMOTE_HASH" && "$LOCAL_HASH" != "$REMOTE_HASH" ]]; then
        echo "📢 Update available for $SCRIPT_NAME."
        read -p "Would you like to update to the latest version? [y/N] " confirm
        if [[ "$confirm" =~ ^[Yy]$ ]]; then
            echo "🔄 Pulling latest changes..."
            git pull --ff-only
            echo -e "${GREEN}✅ $SCRIPT_NAME has been updated. Please re-run the command.${NC}"
            exit 0
        fi
    fi
    cd - >/dev/null || exit 1
fi

# --- Symlink installation check ---
if [[ ! -L "$INSTALL_PATH" || "$(realpath "$INSTALL_PATH")" != "$REAL_PATH" ]]; then
    echo "🔧 $SCRIPT_NAME is not correctly installed at $INSTALL_PATH."
    echo "   Current script: $REAL_PATH"
    if [[ -L "$INSTALL_PATH" ]]; then
        echo "   Existing symlink points to: $(realpath "$INSTALL_PATH")"
    elif [[ -e "$INSTALL_PATH" ]]; then
        echo "   $INSTALL_PATH exists but is not a symlink."
    else
        echo "   No symlink found at $INSTALL_PATH."
    fi
    read -p "Would you like to install a symlink to this script in /usr/bin? [y/N] " confirm
    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        sudo ln -sf "$REAL_PATH" "$INSTALL_PATH"
        echo "✅ Symlink created: $INSTALL_PATH → $REAL_PATH"
        chmod +x "$INSTALL_PATH"
        chmod +x "$REAL_PATH"
        echo "You can now run this script from anywhere using: $SCRIPT_NAME"
        exit 0
    else
        echo "ℹ️ Skipping installation. Running locally."
    fi
fi

# --- Parse options ---
FOLLOW=false
KILL_MODE=false
BY_PORT=false
PORT=""
PROCESS_NAME=""

while [[ $# -gt 0 ]]; do
    case "$1" in
        -f) FOLLOW=true; shift ;;
        -k|--kill) KILL_MODE=true; shift ;;
        -p|--by-port)
            BY_PORT=true
            PORT="${2-}"   # safe even if $2 is unset
            if [[ -z "$PORT" ]]; then
                echo "❌ --by-port requires a port number"
                exit 1
            fi
            if ! [[ "$PORT" =~ ^[0-9]+$ ]]; then
                echo "❌ Invalid port number: $PORT"
                exit 1
            fi
            shift 2  # consume option and port
            ;;
        -*) echo "❌ Invalid option: $1" >&2; exit 1 ;;
        *) PROCESS_NAME="$1"; shift; break ;;
    esac
done

# --- Require either a process name or port ---
if [[ -z "$PROCESS_NAME" && "$BY_PORT" = false ]]; then
    echo "Usage: $SCRIPT_NAME [-f] [-k|--kill] [-p PORT|--by-port PORT] <process-name>"
    exit 1
fi

# --- Functions ---

# Get processes by process name
get_processes_by_name() {
    ps -eo pid,pcpu,pmem,comm,args |
    awk -v name="$PROCESS_NAME" '
        BEGIN { IGNORECASE=1 }
        NR==1 || ($0 ~ name && $0 !~ /awk/ && $0 !~ /procfind/ && $0 !~ /sed/)
    '
}

# Get PID(s) listening on a port
get_processes_by_port() {
    if ! command -v netstat >/dev/null 2>&1; then
        echo "❌ netstat not found. Please install net-tools."
        exit 1
    fi
    netstat -tulpn 2>/dev/null | grep ":$PORT " | awk '{print $7}' | sed 's#/.*##'
}

# Unified get_processes function
get_processes() {
    if [[ "$BY_PORT" = true ]]; then
        local pids
        pids=$(get_processes_by_port)
        if [[ -z "$pids" ]]; then
            echo "PID  %CPU %MEM COMMAND ARGS"
            return
        fi
        for pid in $pids; do
            ps -p "$pid" -o pid,pcpu,pmem,comm,args
        done
    else
        get_processes_by_name
    fi
}

# Highlight matches
highlight_matches() {
    local text="${1-}"  # default to empty string if $1 unset
    if [[ -z "$text" ]]; then
        # Read from stdin if no argument
        text=$(cat)
    fi

    if [[ "$BY_PORT" = true ]]; then
        echo "$text"
    else
        echo "$text" | sed -E "s/($PROCESS_NAME)/${RED}\1${NC}/Ig"
    fi
}

# --- Kill mode ---
if $KILL_MODE; then
    mapfile -t PROCESSES < <(get_processes | tail -n +2)

    if [[ ${#PROCESSES[@]} -eq 0 ]]; then
        echo "No matching processes found."
        exit 0
    fi

    HEADER=$(get_processes | head -n 1)
    echo "Matching processes:"
    printf "%-4s %s\n" "#" "$HEADER"

    i=1
    for proc in "${PROCESSES[@]}"; do
        printf "%-4s %s\n" "$i" "$(highlight_matches "$proc")"
        ((i++))
    done

    echo
    read -rp "Enter process number to kill (or 'A' to kill all): " choice

    if [[ "$choice" =~ ^[Aa]$ ]]; then
        echo "Killing all matching processes..."
        for proc in "${PROCESSES[@]}"; do
            PID=$(echo "$proc" | awk '{print $1}')
            kill -9 "$PID" && echo "Killed PID $PID"
        done
    elif [[ "$choice" =~ ^[0-9]+$ ]] && (( choice >= 1 && choice <= ${#PROCESSES[@]} )); then
        PID=$(echo "${PROCESSES[$((choice-1))]}" | awk '{print $1}')
        echo "Killing PID $PID..."
        kill -9 "$PID" && echo "Killed PID $PID"
    else
        echo "Invalid choice."
        exit 1
    fi
    exit 0
fi

# --- Follow mode ---
if $FOLLOW; then
    while true; do
        clear
        if [[ "$BY_PORT" = true ]]; then
            echo "🔍 Monitoring port: $PORT"
        else
            echo "🔍 Monitoring process: $PROCESS_NAME"
        fi
        echo
        matches=$(get_processes | highlight_matches)

        if [ "$(echo "$matches" | wc -l)" -le 1 ]; then
            echo "None"
        else
            echo "$matches"
        fi
        sleep 2
    done
else
    matches=$(get_processes | highlight_matches)
    if [ "$(echo "$matches" | wc -l)" -le 1 ]; then
        echo "None"
    else
        echo "$matches"
    fi
fi
